# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Union
from lighter.models.market_config import MarketConfig
from typing import Optional, Set
from typing_extensions import Self

class PerpsOrderBookDetail(BaseModel):
    """
    PerpsOrderBookDetail
    """ # noqa: E501
    symbol: StrictStr
    market_id: StrictInt
    market_type: StrictStr
    base_asset_id: StrictInt
    quote_asset_id: StrictInt
    status: StrictStr
    taker_fee: StrictStr
    maker_fee: StrictStr
    liquidation_fee: StrictStr
    min_base_amount: StrictStr
    min_quote_amount: StrictStr
    order_quote_limit: StrictStr
    supported_size_decimals: StrictInt
    supported_price_decimals: StrictInt
    supported_quote_decimals: StrictInt
    size_decimals: StrictInt
    price_decimals: StrictInt
    quote_multiplier: StrictInt
    default_initial_margin_fraction: StrictInt
    min_initial_margin_fraction: StrictInt
    maintenance_margin_fraction: StrictInt
    closeout_margin_fraction: StrictInt
    last_trade_price: Union[StrictFloat, StrictInt]
    daily_trades_count: StrictInt
    daily_base_token_volume: Union[StrictFloat, StrictInt]
    daily_quote_token_volume: Union[StrictFloat, StrictInt]
    daily_price_low: Union[StrictFloat, StrictInt]
    daily_price_high: Union[StrictFloat, StrictInt]
    daily_price_change: Union[StrictFloat, StrictInt]
    open_interest: Union[StrictFloat, StrictInt]
    daily_chart: Dict[str, Union[StrictFloat, StrictInt]]
    market_config: MarketConfig
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["symbol", "market_id", "market_type", "base_asset_id", "quote_asset_id", "status", "taker_fee", "maker_fee", "liquidation_fee", "min_base_amount", "min_quote_amount", "order_quote_limit", "supported_size_decimals", "supported_price_decimals", "supported_quote_decimals", "size_decimals", "price_decimals", "quote_multiplier", "default_initial_margin_fraction", "min_initial_margin_fraction", "maintenance_margin_fraction", "closeout_margin_fraction", "last_trade_price", "daily_trades_count", "daily_base_token_volume", "daily_quote_token_volume", "daily_price_low", "daily_price_high", "daily_price_change", "open_interest", "daily_chart", "market_config"]

    @field_validator('market_type')
    def market_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['perp', 'spot']):
            raise ValueError("must be one of enum values ('perp', 'spot')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['inactive', 'active']):
            raise ValueError("must be one of enum values ('inactive', 'active')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PerpsOrderBookDetail from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of market_config
        if self.market_config:
            _dict['market_config'] = self.market_config.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PerpsOrderBookDetail from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "symbol": obj.get("symbol"),
            "market_id": obj.get("market_id"),
            "market_type": obj.get("market_type"),
            "base_asset_id": obj.get("base_asset_id"),
            "quote_asset_id": obj.get("quote_asset_id"),
            "status": obj.get("status"),
            "taker_fee": obj.get("taker_fee"),
            "maker_fee": obj.get("maker_fee"),
            "liquidation_fee": obj.get("liquidation_fee"),
            "min_base_amount": obj.get("min_base_amount"),
            "min_quote_amount": obj.get("min_quote_amount"),
            "order_quote_limit": obj.get("order_quote_limit"),
            "supported_size_decimals": obj.get("supported_size_decimals"),
            "supported_price_decimals": obj.get("supported_price_decimals"),
            "supported_quote_decimals": obj.get("supported_quote_decimals"),
            "size_decimals": obj.get("size_decimals"),
            "price_decimals": obj.get("price_decimals"),
            "quote_multiplier": obj.get("quote_multiplier"),
            "default_initial_margin_fraction": obj.get("default_initial_margin_fraction"),
            "min_initial_margin_fraction": obj.get("min_initial_margin_fraction"),
            "maintenance_margin_fraction": obj.get("maintenance_margin_fraction"),
            "closeout_margin_fraction": obj.get("closeout_margin_fraction"),
            "last_trade_price": obj.get("last_trade_price"),
            "daily_trades_count": obj.get("daily_trades_count"),
            "daily_base_token_volume": obj.get("daily_base_token_volume"),
            "daily_quote_token_volume": obj.get("daily_quote_token_volume"),
            "daily_price_low": obj.get("daily_price_low"),
            "daily_price_high": obj.get("daily_price_high"),
            "daily_price_change": obj.get("daily_price_change"),
            "open_interest": obj.get("open_interest"),
            "daily_chart": obj.get("daily_chart"),
            "market_config": MarketConfig.from_dict(obj["market_config"]) if obj.get("market_config") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


