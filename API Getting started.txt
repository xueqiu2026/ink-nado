# **Getting started[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/getting-started.html#getting-started)**

# **Introduction[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/getting-started.html#introduction)**

This SDK offers methods to perform all operations on Nado such as trading, managing your collaterals, etc.

# **Basic usage[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/getting-started.html#basic-usage)**

Before you start, import the necessary utilities:

`import time
from nado_protocol.client import create_nado_client
from nado_protocol.engine_client.types.execute import (
    OrderParams,
    PlaceOrderParams,
    WithdrawCollateralParams,
    CancelOrdersParams
)
from nado_protocol.contracts.types import DepositCollateralParams
from nado_protocol.utils.bytes32 import subaccount_to_bytes32, subaccount_to_hex
from nado_protocol.utils.expiration import OrderType, get_expiration_timestamp
from nado_protocol.utils.math import to_pow_10, to_x18
from nado_protocol.utils.nonce import gen_order_nonce
from nado_protocol.utils.subaccount import SubaccountParams
from nado_protocol.utils.order import build_appendix`

The following sections outline the main functionalities:

# **Making a deposit[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/getting-started.html#making-a-deposit)**

**Note**

Remember to always keep your signer‚Äôs private key securely stored and never expose it to the public.

The primary entry point of the SDK is via¬†create_nado_client, which allows you to create an instance of¬†NadoClient. See¬†[API Reference](https://nadohq.github.io/nado-python-sdk/api-reference.html)¬†for more details.

`private_key = "xxx"
print("setting up nado client...")
client = create_nado_client("devnet", private_key)
# You must first approve allowance for the amount you want to deposit.
print("approving allowance...")
approve_allowance_tx_hash = client.spot.approve_allowance(0, to_pow_10(100000, 6))
print("approve allowance tx hash:", approve_allowance_tx_hash)
# Now, you can make the actual deposit.
print("depositing collateral...")
deposit_tx_hash = client.spot.deposit(
        DepositCollateralParams(
            subaccount_name="default", product_id=0, amount=to_pow_10(100000, 6)
        )
    )
print("deposit collateral tx hash:", deposit_tx_hash)`

# **Placing an order[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/getting-started.html#placing-an-order)**

Places an order via¬†[execute:place_order](https://nadohq.github.io/nado-python-sdk/TODO).

`owner = client.context.engine_client.signer.address
print("placing order...")
product_id = 1
order = OrderParams(
        sender=SubaccountParams(
            subaccount_owner=owner,
            subaccount_name="default",
        ),
        priceX18=to_x18(20000),
        amount=to_pow_10(1, 17),
        expiration=get_expiration_timestamp(40),
        nonce=gen_order_nonce(),
        appendix=build_appendix(OrderType.POST_ONLY)
    )
res = client.market.place_order(PlaceOrderParams(product_id=1, order=order))
print("order result:", res.json(indent=2))`

# **Viewing open orders[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/getting-started.html#viewing-open-orders)**

Queries your open orders via¬†[query:subaccount_orders](https://nadohq.github.io/nado-python-sdk/TODO).

`sender = subaccount_to_hex(order.sender)
print("querying open orders...")
open_orders = client.market.get_subaccount_open_orders(1, sender)
print("open orders:", open_orders.json(indent=2))`

# **Retrieving an order digest[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/getting-started.html#retrieving-an-order-digest)**

**Note**

The order digest is necessary to perform order cancellation via¬†client.market.cancel_orders

`order.sender = subaccount_to_bytes32(order.sender)
order_digest = client.context.engine_client.get_order_digest(order, product_id)
print("order digest:", order_digest)`

# **Cancelling an order[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/getting-started.html#cancelling-an-order)**

Cancels open orders via¬†[execute:cancel_orders](https://nadohq.github.io/nado-python-sdk/TODO).

`print("cancelling order...")
res = client.market.cancel_orders(
        CancelOrdersParams(productIds=[product_id], digests=[order_digest], sender=sender)
    )
print("cancel order result:", res.json(indent=2))`

# **Withdrawing collateral[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/getting-started.html#withdrawing-collateral)**

Withdraw spot collaterals from Nado via¬†[execute:withdraw_collateral](https://nadohq.github.io/nado-python-sdk/TODO).

`print("withdrawing collateral...")
withdraw_collateral_params = WithdrawCollateralParams(
        productId=0, amount=to_pow_10(10000, 6), sender=sender
    )
res = client.spot.withdraw(withdraw_collateral_params)
print("withdraw result:", res.json(indent=2))`

# **User reference[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#user-reference)**

# **Core client[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#core-client)**

You must initialize the Nado client via the¬†create_nado_client¬†util for proper setup:

**Note**

You can instantiate the client by providing either a private key, or an instance of¬†LocalAccount.

`from eth_account import Account
from eth_account.signers.local import LocalAccount
from nado_protocol.client import create_nado_client
client_from_private_key = create_nado_client("devnet", "xxx")
signer: LocalAccount = Account.from_key("xxx")
client_from_signer = create_nado_client("devnet", signer)`

See¬†[**`nado_protocol.client.create_nado_client()`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.client.create_nado_client)¬†for details.

**Note**

**Your private key is only used to sign transactions locally.**¬†You can optionally interact with the EIP-712 utilities directly (see¬†[nado-protocol.contracts.eip712](https://nadohq.github.io/nado-python-sdk/api-reference.html#eip-712)) to construct the required signatures for each of Nado‚Äôs executes.

The core Nado client is sub-divided into the following APIs:

# **Market API[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#market-api)**

The Market API allows you to manage and execute orders on the Nado Protocol. Here, you can explore:

- [Placing an order](https://nadohq.github.io/nado-python-sdk/TODO):

`from nado_protocol.engine_client.types import OrderParams, PlaceOrderParams
from nado_protocol.utils.order import build_appendix
from nado_protocol.utils.expiration import OrderType
appendix = build_appendix(order_type=OrderType.IOC, reduce_only=True)
order = OrderParams(..., appendix=appendix)
client.market.place_order(PlaceOrderParams(order=order, ...))`

- [Canceling an order](https://nadohq.github.io/nado-python-sdk/TODO):

`from nado-protocol.engine_client.types import CancelOrdersParams
client.market.cancel_orders(CancelOrdersParams(...))`

- [Cancelling all orders](https://nadohq.github.io/nado-python-sdk/TODO):

`>>> from nado-protocol.engine_client.types import CancelProductOrdersParams
>>> client.market.cancel_product_orders(CancelProductOrdersParams(...))`

- [Minting LP](https://nadohq.github.io/nado-python-sdk/TODO):
    
    `from nado-protocol.engine_client.types import MintNlpParams
    client.market.mint_nlp(MintNlpParams(...))`
    
- [Burning LP](https://nadohq.github.io/nado-python-sdk/TODO):
    
    `from nado-protocol.engine_client.types import BurnNlpParams
    client.market.burn_nlp(BurnNlpParams(...))`
    

You also have available the following queries:

- [Retrieves all market states from the off-chain engine](https://nadohq.github.io/nado-python-sdk/TODO):

`client.market.get_all_engine_markets()`

- [Retrieves liquidity per price tick from the engine](https://nadohq.github.io/nado-python-sdk/TODO):

`client.market.get_market_liquidity()`

- [Retrieves the latest off-chain orderbook price for a specific product](https://nadohq.github.io/nado-python-sdk/TODO):

`client.market.get_latest_market_price(1)`

- [Retrieves subaccount open orders](https://nadohq.github.io/nado-python-sdk/TODO):

`sender = "0xe526299d13c956ed6b9b3e03086a152c6396947364656661756c740000000000"
client.market.get_subaccount_open_orders(1, sender)`

- [Retrieves subaccount historical orders](https://nadohq.github.io/nado-python-sdk/TODO):

`from nado_protocol.indexer_client.types import IndexerSubaccountHistoricalOrdersParams
sender = "0xe526299d13c956ed6b9b3e03086a152c6396947364656661756c740000000000"
params = IndexerSubaccountHistoricalOrdersParams(subaccount=sender)
client.market.get_subaccount_historical_orders(params)`

- [Retrieves historical orders by digest](https://nadohq.github.io/nado-python-sdk/TODO):

`digests = ["0xf4f7a8767faf0c7f72251a1f9e5da590f708fd9842bf8fcdeacbaa0237958fff"]
client.market.get_historical_orders_by_digest(digests)`

- [Retrieves the max amount of LP mintable possible for a subaccount](https://nadohq.github.io/nado-python-sdk/TODO):

`sender = "0xe526299d13c956ed6b9b3e03086a152c6396947364656661756c740000000000"
client.market.get_max_nlp_mintable(1, sender)`

- [Retrieves candlesticks for a product](https://nadohq.github.io/nado-python-sdk/TODO):

`from nado_protocol.indexer_client.types import IndexerCandlesticksParams, IndexerCandlesticksGranularity
params = IndexerCandlesticksParams(product_id=1, granularity=IndexerCandlesticksGranularity.FIVE_MINUTES)
client.market.get_candlesticks(params)`

- [Retrieves the latest funding rate for a specific perp product](https://nadohq.github.io/nado-python-sdk/TODO):

`client.market.get_perp_funding_rate(2)`

- [Retrieves the latest oracle prices for provided products](https://nadohq.github.io/nado-python-sdk/TODO):

`client.market.get_oracle_prices([1, 2, 3, 4])`

- [Retrieves token rewards for a wallet](https://nadohq.github.io/nado-python-sdk/TODO):

`wallet = "0xf8d240d9514c9a4715d66268d7af3b53d6196425"
client.market.get_token_rewards(wallet)`

**Note**

See¬†[**`nado_protocol.client.apis.MarketAPI`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.client.apis.MarketAPI)¬†to explore all available operations.

# **Spot API[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#spot-api)**

The Spot API allows you to manage your spot collaterals. Here, you can explore:

- [Making a deposit](https://nadohq.github.io/nado-python-sdk/TODO):

`from nado_protocol.utils.math import to_pow_10
from nado_protocol.contracts.types import DepositCollateralParams
deposit_tx_hash = client.spot.deposit(
        DepositCollateralParams(
            subaccount_name="default", product_id=0, amount=to_pow_10(100000, 6)
        )
    )`

See¬†[**`nado_protocol.client.apis.SpotExecuteAPI.deposit()`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.client.apis.SpotExecuteAPI.deposit)¬†for details.

- [Withdrawing collateral](https://nadohq.github.io/nado-python-sdk/TODO):

`from nado_protocol.engine_client.types import WithdrawCollateralParams
sender = "0xe526299d13c956ed6b9b3e03086a152c6396947364656661756c740000000000"
withdraw_collateral_params = WithdrawCollateralParams(
        productId=0, amount=to_pow_10(10000, 6), sender=sender
    )
client.spot.withdraw(withdraw_collateral_params)`

**Note**

See¬†[**`nado_protocol.client.apis.SpotAPI`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.client.apis.SpotAPI)¬†to explore all available operations.

# **Perp API[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#perp-api)**

The Perp API for actions and queries specific to Perps. Here, you can explore:

- [Retrieves the latest index and mark price for a specific perp product](https://nadohq.github.io/nado-python-sdk/TODO):

`client.perp.get_prices(2)`

**Note**

See¬†[**`nado_protocol.client.apis.PerpAPI`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.client.apis.PerpAPI)¬†to explore all available operations.

# **Subaccount API[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#subaccount-api)**

The Subaccount API allows you to manage your subaccounts. Here, you can explore:

- [Link a signer to a subaccount](https://nadohq.github.io/nado-python-sdk/TODO):

`from nado_protocol.engine_client.types import LinkSignerParams
params = LinkSignerParams(signer="0xeae27ae6412147ed6d5692fd91709dad6dbfc34264656661756c740000000000")
client.subaccount.link_signer(params)`

- [Retrieves the sate of a subaccount in the off-chain engine](https://nadohq.github.io/nado-python-sdk/TODO):

`sender = "0xe526299d13c956ed6b9b3e03086a152c6396947364656661756c740000000000"
client.subaccount.get_engine_subaccount_summary(sender)`

- [Retrieves subaccount fee rates](https://nadohq.github.io/nado-python-sdk/TODO):

`sender = "0xe526299d13c956ed6b9b3e03086a152c6396947364656661756c740000000000"
client.subaccount.get_subaccount_fee_rates(sender)`

**Note**

See¬†[**`nado_protocol.client.apis.SubaccountAPI`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.client.apis.SubaccountAPI)¬†to explore all available operations.

# **Engine Client[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#engine-client)**

The Engine Client provides low-level functionalities that are integral to interacting with the Nado Protocol, including:

- Signing transactions:

`client.context.engine_client.sign(...)`

- Getting the signer address:

`client.context.engine_client.signer.address`

- Getting an order digest:

`client.context.engine_client.get_order_digest()`

**Note**

See¬†[**`nado_protocol.engine_client`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#module-nado_protocol.engine_client)¬†to explore all available operations.

# **Indexer Client[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#indexer-client)**

The Indexer Client provides functionalities for interacting with the Nado Protocol indexer. This can be particularly useful for fetching historical data. Here you can explore:

`# Retrieves subaccount historical matches.
client.context.indexer_client.get_matches(...)
# Retrieves linked signer rate limits
client.context.indexer_client.get_linked_signer_rate_limits(...)`

**Note**

See¬†[**`nado_protocol.indexer_client`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#module-nado_protocol.indexer_client)¬†to explore all available operations.

# **Nado Contracts[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#nado-contracts)**

A utility module to interact directly with Nado contracts. You can interface with this module via the client‚Äôs context (see¬†[**`nado_protocol.client.NadoClientContext`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.client.NadoClientContext)).

`# approving allowance
client.context.contracts.approve_allowance(...)
# executing a contract function, retrieves the OffchainBook for product_id 1
client.context.contract.endpoint.functions.getBook(1).call()`

**Note**

See¬†[**`nado_protocol.contracts.NadoContracts`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.contracts.NadoContracts)¬†to explore all available operations.

# **Nado utils[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-reference.html#nado-utils)**

A set of utility helpers. See¬†[**`nado_protocol.utils`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#module-nado_protocol.utils).

The utils module includes powerful order appendix functionality for advanced trading features like isolated positions, TWAP orders, and custom execution types. See¬†[Order Appendix](https://nadohq.github.io/nado-python-sdk/order-appendix.html)¬†for comprehensive documentation.

See¬†[API Reference](https://nadohq.github.io/nado-python-sdk/api-reference.html)¬†for detailed information about each module.

# **User guides[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-guides.html#user-guides)**

# **Signing[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-guides.html#signing)**

Signing is handled internally when you instantiate the¬†NadoClient¬†([**`nado_protocol.client.NadoClient`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.client.NadoClient)) with a¬†signer. Alternatively, you can construct the requisite signatures for each execute using a set utils provided by the SDK (see¬†[**`nado_protocol.contracts.eip712`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#module-nado_protocol.contracts.eip712)¬†for details).

**Note**

Check out our docs to learn more about¬†[signing requests](https://nadohq.github.io/nado-python-sdk/TODO)¬†in Nado.

### **EIP-712[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-guides.html#eip-712)**

Nado executes are signed using¬†[EIP-712](https://eips.ethereum.org/EIPS/eip-712)¬†signatures. The following components are needed:

- **types**: The solidity object name and field types of the message being signed.
- **primaryType**: The name of the solidity object being signed.
- **domain**: A protocol-specific object that includes the verifying contract and¬†chain-id¬†of the network.
- **message**: The actual message being signed.

You can build the expected EIP-712 typed data for each execute via¬†[**`nado_protocol.contracts.eip712.build_eip712_typed_data()`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.contracts.eip712.build_eip712_typed_data)

**Place Order Example:**

`import time
from nado_protocol.contracts.types import NadoExecuteType
from nado_protocol.engine_client.types import OrderParams, SubaccountParams
from nado_protocol.utils import subaccount_to_bytes32, to_x18, to_pow_10, get_expiration_timestamp, gen_order_nonce, OrderType
from nado_protocol.utils.order import build_appendix, gen_order_verifying_contract
from nado_protocol.contracts.eip712 import build_eip712_typed_data

# For place orders, use product-specific verifying contract
product_id = 1
verifying_contract = gen_order_verifying_contract(product_id)  # "0x0000000000000000000000000000000000000001"
chain_id = 421613
sender = SubaccountParams(subaccount_owner="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266", subaccount_name="default")
order_nonce = gen_order_nonce()
order_expiration = get_expiration_timestamp(40)
appendix = build_appendix(OrderType.POST_ONLY)
order = OrderParams(amount=to_x18(20000), priceX18=to_pow_10(1, 17), expiration=order_expiration, nonce=order_nonce, sender=sender, appendix=appendix)
order_typed_data = build_eip712_typed_data(NadoExecuteType.PLACE_ORDER, order.dict(), verifying_contract, chain_id)`

**Other Execute Types Example:**

`from nado_protocol.contracts.types import NadoExecuteType
from nado_protocol.engine_client.types import CancelOrdersParams
from nado_protocol.contracts.eip712 import build_eip712_typed_data

# For non-place-order executes, use main endpoint verifying contract
endpoint_verifying_contract = "0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6"  # from get_contracts()
chain_id = 421613
cancel_params = CancelOrdersParams(sender=sender, productIds=[1], digests=["0x..."], nonce=1)
cancel_typed_data = build_eip712_typed_data(NadoExecuteType.CANCEL_ORDERS, cancel_params.dict(), endpoint_verifying_contract, chain_id)`

The following object is generated and can be signed via¬†[**`nado_protocol.contracts.eip712.sign_eip712_typed_data()`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.contracts.eip712.sign_eip712_typed_data):

`{
    'types': {
        'EIP712Domain': [
            {'name': 'name', 'type': 'string'},
            {'name': 'version', 'type': 'string'},
            {'name': 'chainId', 'type': 'uint256'},
            {'name': 'verifyingContract', 'type': 'address'}
        ],
        'Order': [
            {'name': 'sender', 'type': 'bytes32'},
            {'name': 'priceX18', 'type': 'int128'},
            {'name': 'amount', 'type': 'int128'},
            {'name': 'expiration', 'type': 'uint64'},
            {'name': 'nonce', 'type': 'uint64'},
            {'name': 'appendix', 'type': 'uint128'}
        ]
    },
    'primaryType': 'Order',
    'domain': {
        'name': 'Nado',
        'version': '0.0.1',
        'chainId': 421613,
        'verifyingContract': '0x0000000000000000000000000000000000000001'  # Product-specific for place orders
    },
    'message': {
        'sender': b'\xf3\x9f\xd6\xe5\x1a\xad\x88\xf6\xf4\xcej\xb8\x82ry\xcf\xff\xb9"fdefault\x00\x00\x00\x00\x00',
        'nonce': 1768628938411606731,
        'priceX18': 100000000000000000,
        'amount': 20000000000000000000000,
        'expiration': 1686695965,
        'appendix': 0
    }
}`

### **Verifying Contracts[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-guides.html#verifying-contracts)**

**Important**: Different execute types use different verifying contracts for signatures:

- **Place Order (`PLACE_ORDER`)**: Uses a product-specific verifying contract generated via¬†**`nado_protocol.utils.order.gen_order_verifying_contract(product_id)`**
    
    `from nado_protocol.utils.order import gen_order_verifying_contract
    verifying_contract = gen_order_verifying_contract(1)  # "0x0000000000000000000000000000000000000001"`
    
- **All other executes**¬†(CANCEL_ORDERS,¬†WITHDRAW_COLLATERAL, etc.): Use the main endpoint verifying contract from¬†[**`nado_protocol.engine_client.EngineQueryClient.get_contracts()`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.engine_client.EngineQueryClient.get_contracts)
    
    `contracts = client.context.engine_client.get_contracts()
    verifying_contract = contracts.endpoint_addr`
    

**Note**

- You can retrieve the main endpoint verifying contracts using¬†[**`nado_protocol.engine_client.EngineQueryClient.get_contracts()`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.engine_client.EngineQueryClient.get_contracts). Provided via¬†**client.context.engine_client.get_contracts()**¬†on a¬†NadoClient¬†instance.
- You can also just use the engine client‚Äôs sign utility¬†**`nado_protocol.engine_client.EngineExecuteClient.sign()`**. Provided via¬†**client.context.engine_client.sign()**¬†on a¬†NadoClient¬†instance.

# **TWAP and Trigger Orders[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-guides.html#twap-and-trigger-orders)**

The SDK provides comprehensive support for Time-Weighted Average Price (TWAP) orders and conditional price trigger orders through the¬†**`nado_protocol.trigger_client`**¬†module.

### **TWAP Orders[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-guides.html#twap-orders)**

TWAP (Time-Weighted Average Price) orders allow you to execute large trades over time with controlled slippage and timing. This is particularly useful for:

- **Dollar Cost Averaging (DCA)**: Building positions gradually over time
- **Large Order Execution**: Minimizing market impact when trading large amounts
- **Automated Trading**: Setting up systematic trading strategies

**Basic TWAP Order:**

`from nado_protocol.trigger_client import TriggerClient
from nado_protocol.trigger_client.types import TriggerClientOpts
from nado_protocol.utils.math import to_x18

# Create trigger client
trigger_client = TriggerClient(
    opts=TriggerClientOpts(url=TRIGGER_BACKEND_URL, signer=private_key)
)

# Place a TWAP order to buy 5 BTC over 10 hours
# Uses smart defaults: expiration auto-calculated, nonce auto-generated,
# sender defaults to client's signer address + "default" subaccount
twap_result = trigger_client.place_twap_order(
    product_id=1,
    price_x18=str(to_x18(50_000)),
    total_amount_x18=str(to_x18(5)),
    times=10,
    slippage_frac=0.005,
    interval_seconds=3600,
)`

**Flexible Sender Parameters:**

The SDK provides three ways to specify the sender/subaccount for orders:

`# Option 1: Use defaults (simplest)
# Defaults to client's signer address + "default" subaccount
trigger_client.place_twap_order(
    product_id=1,
    price_x18=str(to_x18(50_000)),
    total_amount_x18=str(to_x18(5)),
    times=10,
    slippage_frac=0.005,
    interval_seconds=3600,
)

# Option 2: Specify subaccount parameters
# Allows custom subaccount_owner and subaccount_name
trigger_client.place_twap_order(
    product_id=1,
    price_x18=str(to_x18(50_000)),
    total_amount_x18=str(to_x18(5)),
    times=10,
    slippage_frac=0.005,
    interval_seconds=3600,
    subaccount_owner="0x123...",
    subaccount_name="trading",
)

# Option 3: Provide sender directly (for advanced use cases)
# Sender can be a hex string or SubaccountParams
trigger_client.place_twap_order(
    product_id=1,
    sender="0xabcd...",  # 32-byte hex sender
    price_x18=str(to_x18(50_000)),
    total_amount_x18=str(to_x18(5)),
    times=10,
    slippage_frac=0.005,
    interval_seconds=3600,
)`

**TWAP with Custom Amounts:**

For advanced strategies, you can specify custom amounts for each execution:

`custom_amounts = [
    str(to_x18(2)),
    str(to_x18(1.5)),
    str(to_x18(1)),
    str(to_x18(0.5)),
]

custom_twap_result = trigger_client.place_twap_order(
    product_id=1,
    price_x18=str(to_x18(51_000)),
    total_amount_x18=str(to_x18(5)),
    times=4,
    slippage_frac=0.01,
    interval_seconds=1800,
    custom_amounts_x18=custom_amounts,
)`

### **Price Trigger Orders[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-guides.html#price-trigger-orders)**

Price trigger orders are conditional orders that execute when specific price conditions are met. Common use cases include:

- **Stop-Loss Orders**: Automatically close positions to limit losses
- **Take-Profit Orders**: Automatically realize gains at target prices
- **Breakout Trading**: Enter positions when price breaks key levels
- **Automated Risk Management**: Set up protective orders

**Supported Trigger Types:**

- `"last_price_above"`: Trigger when last traded price goes above threshold
- `"last_price_below"`: Trigger when last traded price goes below threshold
- `"oracle_price_above"`: Trigger when oracle price goes above threshold
- `"oracle_price_below"`: Trigger when oracle price goes below threshold
- `"mid_price_above"`: Trigger when mid price (bid+ask)/2 goes above threshold
- `"mid_price_below"`: Trigger when mid price (bid+ask)/2 goes below threshold

**Stop-Loss Example:**

`# Stop-loss order: sell if price drops below $45k
# Uses smart defaults: expiration defaults to 7 days, nonce auto-generated
stop_loss = trigger_client.place_price_trigger_order(
    product_id=1,
    price_x18=str(to_x18(44_000)),
    amount_x18=str(-to_x18(1)),
    trigger_price_x18=str(to_x18(45_000)),
    trigger_type="last_price_below",
    reduce_only=True,
)`

**Take-Profit Example:**

`# Take-profit order: sell if price rises above $55k
take_profit = trigger_client.place_price_trigger_order(
    product_id=1,
    price_x18=str(to_x18(56_000)),
    amount_x18=str(-to_x18(1)),
    trigger_price_x18=str(to_x18(55_000)),
    trigger_type="last_price_above",
    reduce_only=True,
)`

### **Complete Trading Strategy[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/user-guides.html#complete-trading-strategy)**

Here‚Äôs how to implement a complete automated trading strategy combining multiple order types:

`# 1. Protective stop-loss
stop_loss = trigger_client.place_price_trigger_order(
    product_id=1,
    price_x18=str(to_x18(44_000)),
    amount_x18=str(-to_x18(2)),
    trigger_price_x18=str(to_x18(45_000)),
    trigger_type="last_price_below",
    reduce_only=True,
)

# 2. Profit-taking target
take_profit = trigger_client.place_price_trigger_order(
    product_id=1,
    price_x18=str(to_x18(58_000)),
    amount_x18=str(-to_x18(2)),
    trigger_price_x18=str(to_x18(57_000)),
    trigger_type="last_price_above",
    reduce_only=True,
)

# 3. Gradual position building with TWAP
dca_strategy = trigger_client.place_twap_order(
    product_id=1,
    price_x18=str(to_x18(52_000)),
    total_amount_x18=str(to_x18(10)),
    times=20,
    slippage_frac=0.005,
    interval_seconds=1800,
)`

**Note**

**Smart Defaults:**

- **expiration**: TWAP orders default to¬†`(times¬†¬†1)¬†¬†interval_seconds¬†+¬†24¬†hours`. Price trigger orders default to 7 days.
- **nonce**: Auto-generated using¬†`gen_order_nonce()`¬†if not provided.
- **sender**: Defaults to client‚Äôs signer address + ‚Äúdefault‚Äù subaccount. Can be customized via¬†`sender`,¬†`subaccount_owner`, or¬†`subaccount_name`¬†parameters.
- **reduce_only**: Defaults to¬†`False`.

**Best Practices for TWAP and Trigger Orders:**

- Use¬†`reduce_only=True`¬†for risk management orders (stop-loss, take-profit)
- Set appropriate¬†`slippage_frac`¬†values (0.5-1% is common for liquid markets)
- Consider market hours and liquidity when setting¬†`interval_seconds`
- Override default¬†`expiration`¬†times if needed for specific strategies
- Test strategies with small amounts before scaling up

# **Margin Manager[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#margin-manager)**

The Margin Manager provides comprehensive margin calculations for your Nado Protocol subaccounts. It calculates health, margin usage, leverage, and position-level metrics to help you understand your account‚Äôs risk profile.

# **Overview[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#overview)**

The margin manager calculates:

- **Health Metrics**: Initial, maintenance, and unweighted health
- **Margin Usage**: Percentage of margin being used (0-100%)
- **Position Metrics**: Individual position details with health contributions
- **Leverage**: Overall account leverage
- **Available Funds**: How much margin is available for new positions

# **Key Concepts[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#key-concepts)**

### **Health Types[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#health-types)**

The system uses three levels of health/margin requirements:

| **Type** | **Purpose** | **Description** |
| --- | --- | --- |
| **Initial** | Open new positions | Strictest requirement. Uses¬†`*_weight_initial`¬†fields (e.g., 0.9 for 10x max leverage) |
| **Maintenance** | Avoid liquidation | Less strict. Uses¬†`*_weight_maintenance`¬†fields (e.g., 0.95 for 20x) |
| **Unweighted** | Raw asset value | No haircuts applied (weight = 1.0). Used as reference. |

### **Health Calculation[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#health-calculation)**

For each balance:

`health_contribution = amount √ó oracle_price √ó weight`

Where weight depends on position direction:

- **Long positions**¬†(amount ‚â• 0): Use¬†`long_weight_*`
- **Short positions**¬†(amount < 0): Use¬†`short_weight_*`

For the entire subaccount:

`assets = sum of positive health contributions
liabilities = sum of negative health contributions (absolute value)
health = assets - liabilities`

**Liquidation occurs when maintenance health < 0.**

**Margin Modes[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#margin-modes)Cross Margin**Margin is shared across all positions. All balances contribute to a single health pool.

`margin_usage = (unweighted_health - initial_health) / unweighted_health`
**Isolated Margin**Dedicated margin per perp position. Only USDT can be used. Max 1 isolated position per market.

`net_margin = quote_amount + unsettled_pnl
leverage = notional_value / net_margin`

# **Quick Start[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#quick-start)**

### **Basic Usage[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#basic-usage)**

`import time
from nado_protocol.client import create_nado_client, NadoClientMode
from nado_protocol.utils.margin_manager import MarginManager, print_account_summary

client = create_nado_client(NadoClientMode.TESTNET)

# Optionally override defaults (subaccount hex, timestamp, etc.)
manager = MarginManager.from_client(
    client,
    include_indexer_events=True,
    snapshot_timestamp=int(time.time()),
)

summary = manager.calculate_account_summary()
print_account_summary(summary)`

If you skip the optional indexer request (`include_indexer_events=False`),¬†`CrossPositionMetrics.est_pnl`¬†remains¬†`None`¬†and the printed summary displays¬†`N/A`¬†for Est. PnL.

Passing¬†`snapshot_active_only=True`¬†(the default) ensures the indexer only returns balances that are live at the requested timestamp, keeping the snapshot focused on current positions.

### **Manual setup (advanced)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#manual-setup-advanced)**

If you need more control over the data-fetching steps, you can assemble the manager yourself:

`import time
from nado_protocol.engine_client import EngineQueryClient, EngineClientOpts
from nado_protocol.indexer_client import IndexerQueryClient, IndexerClientOpts
from nado_protocol.indexer_client.types.query import IndexerAccountSnapshotsParams
from nado_protocol.utils.bytes32 import subaccount_to_hex
from nado_protocol.utils.margin_manager import MarginManager, print_account_summary

# Create read-only clients (no private key needed)
engine_client = EngineQueryClient(
    EngineClientOpts(url="https://gateway.test.nado.xyz/v1")
)
indexer_client = IndexerQueryClient(
    IndexerClientOpts(url="https://archive.test.nado.xyz/v1")
)

# Get subaccount data
wallet_address = "0x1234..."
subaccount = subaccount_to_hex(wallet_address, "default")

subaccount_info = engine_client.get_subaccount_info(subaccount)
isolated_positions = engine_client.get_isolated_positions(subaccount).isolated_positions

# Optional: fetch indexer events for Est. PnL display
current_timestamp = int(time.time())
snapshot_response = indexer_client.get_multi_subaccount_snapshots(
    IndexerAccountSnapshotsParams(
        subaccounts=[subaccount],
        timestamps=[current_timestamp],
        isolated=False,
        active=True,
    )
)
snapshots_map = snapshot_response.snapshots
snapshot_events = []
if snapshots_map:
    snapshots_for_subaccount = snapshots_map.get(subaccount) or next(
        iter(snapshots_map.values())
    )
    if snapshots_for_subaccount:
        latest_key = max(snapshots_for_subaccount.keys(), key=int)
        snapshot_events = snapshots_for_subaccount.get(latest_key, [])
indexer_events = snapshot_events

# Calculate all margin metrics
margin_manager = MarginManager(
    subaccount_info,
    isolated_positions,
    indexer_snapshot_events=indexer_events,
)
summary = margin_manager.calculate_account_summary()

# Display formatted summary
print_account_summary(summary)`

This outputs a complete margin summary:

`================================================================================
MARGIN MANAGER ACCOUNT SUMMARY
================================================================================

üìä HEALTH METRICS
  Initial Health:      $999,543,667.24
  Maintenance Health:  $999,761,007.36
  Unweighted Health:   $1,000,086,939.32

üìà MARGIN USAGE
  Initial Margin:      0.05%
  Maintenance Margin:  0.03%

üí∞ AVAILABLE FUNDS
  Available (Initial):      $999,543,667.24
  Until Liquidation (Maint): $999,761,007.36

üì¶ PORTFOLIO
  Total Value:  $1,000,086,939.32
  Leverage:     0.11x`

# **Tutorial[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#tutorial)**

### **Example 1: Check Account Risk[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#example-1-check-account-risk)**

Monitor your account‚Äôs liquidation risk:

`from nado_protocol.client import create_nado_client
from nado_protocol.utils.bytes32 import subaccount_to_hex
from nado_protocol.utils.margin_manager import MarginManager

# Create client
client = create_nado_client("testnet", private_key)
subaccount = subaccount_to_hex(client.context.signer.address, "default")

# Fetch data
subaccount_info = client.context.engine_client.get_subaccount_info(subaccount)
isolated = client.context.engine_client.get_isolated_positions(subaccount).isolated_positions

# Calculate metrics
margin_manager = MarginManager(subaccount_info, isolated)
summary = margin_manager.calculate_account_summary()

# Check risk level
maint_usage = summary.maint_margin_usage_fraction * 100

if maint_usage > 90:
    print("üî¥ CRITICAL RISK - Near liquidation!")
elif maint_usage > 75:
    print("üü† HIGH RISK - Reduce positions")
elif maint_usage > 50:
    print("üü° MEDIUM RISK")
else:
    print("üü¢ LOW RISK")

print(f"Margin Usage: {maint_usage:.2f}%")
print(f"Leverage: {summary.account_leverage:.2f}x")
print(f"Available Margin: ${summary.funds_available:,.2f}")`

### **Example 2: Analyze Individual Positions[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#example-2-analyze-individual-positions)**

Get detailed metrics for each position:

`# ... setup margin_manager as above ...

summary = margin_manager.calculate_account_summary()

# Cross margin positions
print("\nüîÑ CROSS MARGIN POSITIONS\n")
for pos in summary.cross_positions:
    print(f"Product {pos.product_id}:")
    print(f"  Position Size: {pos.position_size:,.4f}")
    print(f"  Notional: ${pos.notional_value:,.2f}")
    print(f"  Margin Used: ${pos.margin_used:,.2f}")
    print(f"  Initial Health: ${pos.initial_health:,.2f}")
    print(f"  Maint Health: ${pos.maintenance_health:,.2f}")

    # Calculate position-specific margin usage
    if pos.notional_value > 0:
        pos_leverage = pos.notional_value / pos.margin_used
        print(f"  Effective Leverage: {pos_leverage:.2f}x")
    print()

# Isolated margin positions
print("\nüîí ISOLATED MARGIN POSITIONS\n")
for pos in summary.isolated_positions:
    print(f"Product {pos.product_id}:")
    print(f"  Position Size: {pos.position_size:,.4f}")
    print(f"  Notional: ${pos.notional_value:,.2f}")
    print(f"  Net Margin: ${pos.net_margin:,.2f}")
    print(f"  Leverage: {pos.leverage:.2f}x")
    print()`

### **Example 3: Calculate Maximum Position Size[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#example-3-calculate-maximum-position-size)**

Determine how large of a position you can open:

`from decimal import Decimal

# ... setup margin_manager as above ...

summary = margin_manager.calculate_account_summary()

# Get oracle price for a product (e.g., BTC)
btc_product_id = 1
btc_product = next(
    (p for p in subaccount_info.perp_products if p.product_id == btc_product_id),
    None
)

if btc_product:
    from nado_protocol.utils.math import from_x18

    oracle_price = Decimal(from_x18(int(btc_product.oracle_price_x18)))
    long_weight_initial = Decimal(from_x18(int(btc_product.risk.long_weight_initial_x18)))

    # Calculate max position size
    available_margin = summary.funds_available
    leverage_factor = Decimal(1) - long_weight_initial  # e.g., 0.1 for 10x

    max_notional = available_margin / leverage_factor
    max_size = max_notional / oracle_price

    print(f"BTC Oracle Price: ${oracle_price:,.2f}")
    print(f"Available Margin: ${available_margin:,.2f}")
    print(f"Max Position Size: {max_size:.4f} BTC")
    print(f"Max Notional: ${max_notional:,.2f}")`

### **Example 4: Monitor Spot Deposits and Borrows[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#example-4-monitor-spot-deposits-and-borrows)**

Track your spot lending activity:

`# ... setup margin_manager as above ...

summary = margin_manager.calculate_account_summary()

print("üíµ SPOT BALANCE SUMMARY\n")
print(f"Total Deposits: ${summary.total_spot_deposits:,.2f}")
print(f"Total Borrows:  ${summary.total_spot_borrows:,.2f}")
print(f"Net Balance:    ${summary.total_spot_deposits - summary.total_spot_borrows:,.2f}")

# Calculate utilization
if summary.total_spot_deposits > 0:
    utilization = (summary.total_spot_borrows / summary.total_spot_deposits) * 100
    print(f"Utilization:    {utilization:.2f}%")`

### **Example 5: Read-Only Access (No Private Key)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#example-5-read-only-access-no-private-key)**

View any public subaccount‚Äôs margin metrics:

`import time
from nado_protocol.engine_client import EngineQueryClient, EngineClientOpts
from nado_protocol.indexer_client import IndexerQueryClient, IndexerClientOpts
from nado_protocol.indexer_client.types.query import IndexerAccountSnapshotsParams
from nado_protocol.utils.bytes32 import subaccount_to_hex
from nado_protocol.utils.margin_manager import MarginManager

# Any wallet address (no private key needed)
wallet_to_analyze = "0x8D7d64d6cF1D4F018Dd101482Ac71Ad49e30c560"

# Create engine client
engine_client = EngineQueryClient(
    EngineClientOpts(url="https://gateway.test.nado.xyz/v1")
)
indexer_client = IndexerQueryClient(
    IndexerClientOpts(url="https://archive.test.nado.xyz/v1")
)

# Get data
subaccount = subaccount_to_hex(wallet_to_analyze, "default")
subaccount_info = engine_client.get_subaccount_info(subaccount)
isolated = engine_client.get_isolated_positions(subaccount).isolated_positions

# Fetch latest indexer snapshot for Est. PnL (optional)
timestamp = int(time.time())
snapshot = indexer_client.get_multi_subaccount_snapshots(
    IndexerAccountSnapshotsParams(
        subaccounts=[subaccount],
        timestamps=[timestamp],
        isolated=False,
        active=True,
    )
)
indexer_events = snapshot.snapshots.get(subaccount, {}).get(str(timestamp), [])

# Analyze
margin_manager = MarginManager(
    subaccount_info,
    isolated,
    indexer_snapshot_events=indexer_events,
)
summary = margin_manager.calculate_account_summary()

print(f"Analyzing wallet: {wallet_to_analyze}")
print(f"Portfolio Value: ${summary.portfolio_value:,.2f}")
print(f"Leverage: {summary.account_leverage:.2f}x")
print(f"Risk Level: {summary.maint_margin_usage_fraction * 100:.2f}% margin used")`

# **Advanced Usage[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#advanced-usage)**

### **Individual Calculation Methods[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#individual-calculation-methods)**

Use specific calculation methods for custom analytics:

`from nado_protocol.utils.margin_manager import MarginManager
from decimal import Decimal

# ... setup margin_manager ...

# Create a balance object for calculations
from nado_protocol.utils.margin_manager import BalanceWithProduct

balance = BalanceWithProduct(
    product_id=1,
    amount=Decimal("10"),  # 10 BTC long
    oracle_price=Decimal("50000"),
    long_weight_initial=Decimal("0.9"),
    long_weight_maintenance=Decimal("0.95"),
    short_weight_initial=Decimal("1.1"),
    short_weight_maintenance=Decimal("1.05"),
    balance_type="perp",
    v_quote_balance=Decimal("0")
)

# Calculate notional value
notional = margin_manager.calculate_perp_balance_notional_value(balance)
print(f"Notional: ${notional:,.2f}")  # $500,000

# Calculate margin required (without PnL)
health_metrics = margin_manager.calculate_perp_balance_health_without_pnl(balance)
margin_required = abs(health_metrics.initial)
print(f"Margin Required: ${margin_required:,.2f}")  # $50,000 (10x leverage)

# Calculate health contribution
health = margin_manager.calculate_spot_balance_health(balance)
print(f"Initial Health: ${health.initial:,.2f}")
print(f"Maint Health: ${health.maintenance:,.2f}")`

### **Balance Value Utilities[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#balance-value-utilities)**

Use the balance utility functions for quick calculations:

`from nado_protocol.utils.balance import (
    calculate_spot_balance_value,
    calculate_perp_balance_notional_value,
    calculate_perp_balance_value,
    parse_spot_balance_value,
    parse_perp_balance_value,
)
from decimal import Decimal

# Direct calculations
eth_value = calculate_spot_balance_value(
    amount=Decimal("100"),
    oracle_price=Decimal("2000")
)
print(f"ETH Value: ${eth_value:,.2f}")  # $200,000

# Perp notional
btc_notional = calculate_perp_balance_notional_value(
    amount=Decimal("-5"),  # 5 BTC short
    oracle_price=Decimal("50000")
)
print(f"BTC Notional: ${btc_notional:,.2f}")  # $250,000

# Parse from SDK types
spot_value = parse_spot_balance_value(balance, product)
perp_value = parse_perp_balance_value(balance, product)`

# **Understanding the Results[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#understanding-the-results)**

### **AccountSummary Fields[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#accountsummary-fields)**

| **Field** | **Description** |
| --- | --- |
| `initial_health` | Health using initial weights. Must be > 0 to open new positions. |
| `maintenance_health` | Health using maintenance weights. Must be > 0 to avoid liquidation. |
| `unweighted_health` | Raw portfolio value without haircuts. |
| `margin_usage_fraction` | Fraction [0, 1] of initial margin being used. |
| `maint_margin_usage_fraction` | Fraction [0, 1] of maintenance margin being used. Risk indicator. |
| `funds_available` | Available margin for new positions (= max(0, initial_health)). |
| `funds_until_liquidation` | Distance to liquidation (= max(0, maintenance_health)). |
| `portfolio_value` | Total portfolio value including isolated positions. |
| `account_leverage` | Overall leverage multiplier. |
| `cross_positions` | List of cross margin position metrics. |
| `isolated_positions` | List of isolated margin position metrics. |
| `total_spot_deposits` | Total value of spot deposits. |
| `total_spot_borrows` | Total value of spot borrows (absolute). |

### **CrossPositionMetrics Fields[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#crosspositionmetrics-fields)**

| **Field** | **Description** |
| --- | --- |
| `product_id` | Product identifier. |
| `position_size` | Position size (positive for long, negative for short). |
| `notional_value` | Absolute notional value (= abs(size √ó oracle_price)). |
| `est_pnl` | Estimated PnL from indexer (amount √ó oracle_price - netEntryUnrealized). Requires indexer data. |
| `unsettled` | Full perp balance value (amount √ó oracle_price + v_quote_balance). This represents unrealized PnL. |
| `margin_used` | Margin consumed by position, excluding PnL impact. |
| `initial_health` | Health contribution using initial weights. |
| `maintenance_health` | Health contribution using maintenance weights. |

### **IsolatedPositionMetrics Fields[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#isolatedpositionmetrics-fields)**

| **Field** | **Description** |
| --- | --- |
| `product_id` | Product identifier. |
| `position_size` | Position size. |
| `notional_value` | Absolute notional value. |
| `net_margin` | Deposited margin + unsettled PnL. |
| `leverage` | Position leverage (= notional / net_margin). |
| `initial_health` | Health for the isolated position (initial). |
| `maintenance_health` | Health for the isolated position (maintenance). |

---

### **Does margin manager use oracle price or market price?[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#does-margin-manager-use-oracle-price-or-market-price)**

**All margin calculations use ORACLE PRICE.**

Market prices (bid/ask from the orderbook) are only used for: - Estimated exit price for unrealized PnL display -¬†**NOT**¬†for any margin or health calculations

### **Do I need to convert USDT to USD?[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#do-i-need-to-convert-usdt-to-usd)**

**No conversion needed!**¬†All values from the engine are already in the correct denomination.

Oracle prices are denominated in the primary quote token (USDT), and all margin calculations work directly with these values. The UI displays dollar signs ($) as a convention, but no USDT‚ÜíUSD price conversion is applied.

Key points:

- **Perp tracked variables**¬†(`netEntryUnrealized`,¬†`netFundingUnrealized`, etc.) are already in quote (USDT) terms
- **No multiplication by USDT/USD rate**¬†in any margin calculation
- **The only oracle price multiplication**¬†is for spot interest (converting from token units to USD)

### **How do I calculate initial margin for a perp position?[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#how-do-i-calculate-initial-margin-for-a-perp-position)**

Common Questions For a perp position, initial margin is:

`notional = abs(position_size √ó oracle_price)
initial_margin = notional √ó abs(1 - weight_initial)
maintenance_margin = notional √ó abs(1 - weight_maintenance)`

**Important**: Use¬†`abs(1¬†-¬†weight)`¬†to handle both long and short positions:

- **Long positions**: weight < 1, so (1 - weight) > 0
- **Short positions**: weight > 1, so (1 - weight) < 0, need abs()

Example (Long): - Position: 10 BTC long - Oracle Price: $50,000 - Long Weight Initial: 0.9 (allows 10x leverage)

`notional = abs(10 √ó 50,000) = $500,000
initial_margin = 500,000 √ó (1 - 0.9) = 500,000 √ó 0.1 = $50,000`

Example (Short): - Position: -10 BTC short - Oracle Price: $50,000 - Short Weight Initial: 1.1 (requires 10x leverage)

`notional = abs(-10 √ó 50,000) = $500,000
initial_margin = 500,000 √ó abs(1 - 1.1) = 500,000 √ó 0.1 = $50,000`

Both positions require $50,000 initial margin (10x leverage).

### **Why is my margin usage 0% even though I have positions?[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#why-is-my-margin-usage-0-even-though-i-have-positions)**

Margin usage is only calculated when:

1. Unweighted health > 0
2. Account has borrows OR perp positions
3. Zero-health products are excluded

If you only have spot deposits (no borrows, no perps), margin usage will be 0%.

### **What‚Äôs the difference between cross and isolated margin?[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#what-s-the-difference-between-cross-and-isolated-margin)**

**Cross Margin:**¬†- Margin shared across ALL positions - Better capital efficiency - Risk spreads across entire portfolio - Default mode

**Isolated Margin:**¬†- Dedicated margin PER position - Risk limited to individual position - Only USDT can be used as margin - Max 1 isolated position per market - Useful for high-risk trades

### **How is leverage calculated?[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#how-is-leverage-calculated)**

Account leverage:

`leverage = sum(abs(notional_values)) / unweighted_health`

Where notional values include: - Spot: abs(amount √ó oracle_price) for non-quote products - Perp: abs(amount √ó oracle_price)

Quote product (USDT) is excluded from the calculation.

# **API Reference[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#api-reference)**

**MarginManager Class[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#marginmanager-class)*class*nado_protocol.utils.margin_manager.MarginManager(*subaccount_info*,¬†*isolated_positions=None*,¬†*indexer_snapshot_events=None*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager)**Bases:¬†**`object`**
Comprehensive margin calculator for Nado Protocol.
Calculates all margin metrics for a subaccount including health, margin usage, leverage, and position-level details. Matches TypeScript SDK implementation.**QUOTE_PRODUCT_ID*=¬†0*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.QUOTE_PRODUCT_ID)*classmethod*from_client(*client*,¬†***,¬†*subaccount=None*,¬†*subaccount_name='default'*,¬†*include_indexer_events=True*,¬†*snapshot_timestamp=None*,¬†*snapshot_isolated=False*,¬†*snapshot_active_only=True*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.from_client)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.from_client)**Initialize a MarginManager by fetching data via a NadoClient.**Return type:[`MarginManager`](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager)Args:**client: Configured Nado client with engine/indexer connectivity. subaccount: Optional subaccount hex (bytes32). If omitted, derives the defaultsubaccount using the client‚Äôs signer and¬†`subaccount_name`.**subaccount_name: Subaccount suffix (e.g.¬†`default`) used when deriving the**subaccount hex. Ignored when¬†`subaccount`¬†is provided.**include_indexer_events: When True (default), fetch indexer snapshot balances**for estimated PnL calculations.**snapshot_timestamp: Epoch seconds to request from the indexer. Defaults to**`int(time.time())`¬†when indexer data is requested.**snapshot_isolated: Passed through to the indexer request to limit snapshots**to isolated (True), cross (False), or all (None) balances. Defaults to¬†`False`¬†to match cross-margin behaviour.**snapshot_active_only: When True (default), enables the indexer‚Äôs¬†`active`**filter so only live balances are returned.**Returns:**MarginManager instance populated with fresh engine and optional indexer data.**calculate_account_summary()[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_account_summary)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_account_summary)**Calculate complete account margin summary.**Return type:[`AccountSummary`](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary)Returns:**AccountSummary with all margin calculations**calculate_spot_balance_value(*balance*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_spot_balance_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_spot_balance_value)**Calculate quote value of a spot balance.
Formula: amount * oracle_price**Return type:`Decimal`calculate_perp_balance_notional_value(*balance*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_perp_balance_notional_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_perp_balance_notional_value)**Calculate notional value of a perp position.
Formula: abs(amount * oracle_price)**Return type:`Decimal`calculate_perp_balance_value(*balance*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_perp_balance_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_perp_balance_value)**Calculate true quote value of a perp balance (unrealized PnL).
Formula: (amount * oracle_price) + v_quote_balance**Return type:`Decimal`calculate_spot_balance_health(*balance*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_spot_balance_health)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_spot_balance_health)**Calculate health contribution for a spot balance.
Formula: amount * oracle_price * weight (weight is long_weight if amount >= 0, else short_weight)**Return type:[`HealthMetrics`](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.HealthMetrics)calculate_perp_balance_health_without_pnl(*balance*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_perp_balance_health_without_pnl)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_perp_balance_health_without_pnl)**Calculate perp balance health WITHOUT the impact of unsettled PnL.
Shows ‚Äúmargin used‚Äù by the position, excluding PnL. Formula: -1 * abs(notional_value) * (1 - long_weight)**Return type:[`HealthMetrics`](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.HealthMetrics)calculate_cross_position_margin_without_pnl(*balance*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_cross_position_margin_without_pnl)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_cross_position_margin_without_pnl)**Calculate margin used for a cross position excluding unsettled PnL impact.
Used in margin manager ‚ÄúMargin Used‚Äù column. Formula: max(0, -(initial_health - perp_value))**Return type:`Decimal`calculate_isolated_position_net_margin(*base_balance*,¬†*quote_balance*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_isolated_position_net_margin)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_isolated_position_net_margin)**Calculate net margin in an isolated position.
Formula: quote_amount + (base_amount * oracle_price + v_quote_balance)**Return type:`Decimal`calculate_isolated_position_leverage(*base_balance*,¬†*net_margin*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_isolated_position_leverage)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_isolated_position_leverage)**Calculate leverage for an isolated position.
Formula: notional_value / net_margin**Return type:`Decimal`calculate_margin_usage_fractions(*initial_health*,¬†*maint_health*,¬†*unweighted_health*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_margin_usage_fractions)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_margin_usage_fractions)**Calculate margin usage fractions bounded to [0, 1].
Formula: (unweighted_health - health) / unweighted_health Returns 0 if no borrows/perps or unweighted_health is 0.**Return type:[`MarginUsageFractions`](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginUsageFractions)calculate_account_leverage(*balances*,¬†*unweighted_health*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_account_leverage)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_account_leverage)**Calculate overall account leverage.
Formula: sum(abs(unweighted health for non-quote balances)) / unweighted_health**Return type:`Decimal`calculate_cross_position_metrics(*balance*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_cross_position_metrics)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_cross_position_metrics)**Calculate all metrics for a cross margin position.**Return type:[`CrossPositionMetrics`](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics)calculate_isolated_position_metrics(*iso_pos*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginManager.calculate_isolated_position_metrics)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginManager.calculate_isolated_position_metrics)**Calculate all metrics for an isolated position.**Return type:[`IsolatedPositionMetrics`](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics)**

**Models[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#models)*class*nado_protocol.utils.margin_manager.AccountSummary(***data*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#AccountSummary)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary)**Complete account margin summary.**initial_health*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.initial_health)maintenance_health*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.maintenance_health)unweighted_health*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.unweighted_health)margin_usage_fraction*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.margin_usage_fraction)maint_margin_usage_fraction*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.maint_margin_usage_fraction)funds_available*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.funds_available)funds_until_liquidation*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.funds_until_liquidation)portfolio_value*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.portfolio_value)account_leverage*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.account_leverage)cross_positions*:¬†`list`[[`CrossPositionMetrics`](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics)]*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.cross_positions)isolated_positions*:¬†`list`[[`IsolatedPositionMetrics`](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics)]*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.isolated_positions)spot_positions*:¬†`list`[`BalanceWithProduct`]*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.spot_positions)total_spot_deposits*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.total_spot_deposits)total_spot_borrows*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.total_spot_borrows)*class*Config[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#AccountSummary.Config)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.Config)arbitrary_types_allowed*=¬†True*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.AccountSummary.Config.arbitrary_types_allowed)*class*nado_protocol.utils.margin_manager.CrossPositionMetrics(***data*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#CrossPositionMetrics)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics)**Metrics for a cross margin position.**product_id*:¬†`int`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.product_id)symbol*:¬†`str`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.symbol)position_size*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.position_size)notional_value*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.notional_value)est_pnl*:¬†`Optional`[`Decimal`]*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.est_pnl)unsettled*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.unsettled)margin_used*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.margin_used)initial_health*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.initial_health)maintenance_health*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.maintenance_health)long_weight_initial*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.long_weight_initial)long_weight_maintenance*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.long_weight_maintenance)short_weight_initial*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.short_weight_initial)short_weight_maintenance*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.short_weight_maintenance)*class*Config[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#CrossPositionMetrics.Config)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.Config)arbitrary_types_allowed*=¬†True*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.CrossPositionMetrics.Config.arbitrary_types_allowed)*class*nado_protocol.utils.margin_manager.IsolatedPositionMetrics(***data*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#IsolatedPositionMetrics)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics)**Metrics for an isolated margin position.**product_id*:¬†`int`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.product_id)symbol*:¬†`str`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.symbol)position_size*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.position_size)notional_value*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.notional_value)net_margin*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.net_margin)leverage*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.leverage)initial_health*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.initial_health)maintenance_health*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.maintenance_health)*class*Config[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#IsolatedPositionMetrics.Config)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.Config)arbitrary_types_allowed*=¬†True*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.IsolatedPositionMetrics.Config.arbitrary_types_allowed)*class*nado_protocol.utils.margin_manager.HealthMetrics(***data*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#HealthMetrics)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.HealthMetrics)**Initial and maintenance health metrics.**initial*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.HealthMetrics.initial)maintenance*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.HealthMetrics.maintenance)*class*nado_protocol.utils.margin_manager.MarginUsageFractions(***data*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#MarginUsageFractions)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginUsageFractions)**Margin usage as a fraction [0, 1].**initial*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginUsageFractions.initial)maintenance*:¬†`Decimal`*[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.MarginUsageFractions.maintenance)**

### **Utility Functions[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#utility-functions)**

**nado_protocol.utils.margin_manager.print_account_summary(*summary*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/margin_manager.html#print_account_summary)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.margin_manager.print_account_summary)**Print formatted account summary matching UI layout.**Return type:`None`**

Balance Value Calculation Utilities

**nado_protocol.utils.balance.calculate_spot_balance_value(*amount*,¬†*oracle_price*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/balance.html#calculate_spot_balance_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.balance.calculate_spot_balance_value)**Calculate the quote value of a spot balance.
Formula: amount * oracle_price
This is used for: - Calculating health contributions - Determining deposits vs borrows - Portfolio value calculations**Return type:`Decimal`Args:**amount: Token amount (can be negative for borrows) oracle_price: Oracle price in quote currency**Returns:**Value in quote currency (positive for deposits, negative for borrows)**Example:**

`calculate_spot_balance_value(100, 2000)  # 100 ETH at $2000
Decimal('200000')
calculate_spot_balance_value(-50, 2000)  # 50 ETH borrowed
Decimal('-100000')`

**nado_protocol.utils.balance.calculate_perp_balance_notional_value(*amount*,¬†*oracle_price*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/balance.html#calculate_perp_balance_notional_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.balance.calculate_perp_balance_notional_value)**Calculate the notional value of a perp position.
Formula: abs(amount * oracle_price)
This represents the total size of the position in quote currency terms, regardless of direction (long or short).**Return type:`Decimal`Args:**amount: Position size (positive for long, negative for short) oracle_price: Oracle price in quote currency**Returns:**Absolute notional value in quote currency**Example:**

`calculate_perp_balance_notional_value(10, 50000)  # 10 BTC long
Decimal('500000')
calculate_perp_balance_notional_value(-10, 50000)  # 10 BTC short
Decimal('500000')`

**nado_protocol.utils.balance.calculate_perp_balance_value(*amount*,¬†*oracle_price*,¬†*v_quote_balance*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/balance.html#calculate_perp_balance_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.balance.calculate_perp_balance_value)**Calculate the true quote value of a perp balance (unrealized PnL).
Formula: (amount * oracle_price) + v_quote_balance
The v_quote_balance represents: - Unrealized PnL from price changes - Accumulated funding payments - Entry cost adjustments
This value is what would be added to your balance if the position were closed.**Return type:`Decimal`Args:**amount: Position size oracle_price: Oracle price in quote currency v_quote_balance: Virtual quote balance (unsettled PnL)**Returns:**Total value in quote currency (can be positive or negative)**Example:**

`# Long 10 BTC at $50k, now at $51k, with funding
calculate_perp_balance_value(10, 51000, -500000)
Decimal('10000')  # $10k profit`

**nado_protocol.utils.balance.parse_spot_balance_value(*balance*,¬†*product*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/balance.html#parse_spot_balance_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.balance.parse_spot_balance_value)**Parse spot balance value from raw SDK types.
This is a convenience function that extracts values from the SDK types and calls calculate_spot_balance_value.**Return type:`Decimal`Args:**balance: Spot balance from subaccount info product: Spot product information**Returns:**Balance value in quote currency

**nado_protocol.utils.balance.parse_perp_balance_notional_value(*balance*,¬†*product*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/balance.html#parse_perp_balance_notional_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.balance.parse_perp_balance_notional_value)**Parse perp notional value from raw SDK types.**Return type:`Decimal`Args:**balance: Perp balance from subaccount info product: Perp product information**Returns:**Notional value in quote currency

**nado_protocol.utils.balance.parse_perp_balance_value(*balance*,¬†*product*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/balance.html#parse_perp_balance_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.balance.parse_perp_balance_value)**Parse perp balance value (unrealized PnL) from raw SDK types.**Return type:`Decimal`Args:**balance: Perp balance from subaccount info product: Perp product information**Returns:**Balance value in quote currency

**nado_protocol.utils.balance.calculate_total_spot_deposits_and_borrows(*balances*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/balance.html#calculate_total_spot_deposits_and_borrows)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.balance.calculate_total_spot_deposits_and_borrows)**Calculate total spot deposits and borrows across all balances.**Return type:`tuple`**[**`Decimal`**,¬†**`Decimal`**]**Args:**balances: List of (balance, product) tuples**Returns:**Tuple of (total_deposits, total_borrows) in quote currency Both values are positive (borrows is absolute value)**Example:**

`balances = [(usdt_balance, usdt_product), (eth_balance, eth_product)]
deposits, borrows = calculate_total_spot_deposits_and_borrows(balances)
deposits  # Total deposits
Decimal('10000')
borrows   # Total borrows (absolute value)
Decimal('5000')`

**nado_protocol.utils.balance.calculate_total_perp_notional(*balances*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/balance.html#calculate_total_perp_notional)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.balance.calculate_total_perp_notional)**Calculate total notional value across all perp positions.**Return type:`Decimal`Args:**balances: List of (balance, product) tuples**Returns:**Total notional value in quote currency**Example:**

`balances = [(btc_perp_balance, btc_perp_product)]
total = calculate_total_perp_notional(balances)
total
Decimal('500000')  # Total position size`

**nado_protocol.utils.balance.calculate_total_perp_value(*balances*)[[source]](https://nadohq.github.io/nado-python-sdk/_modules/nado_protocol/utils/balance.html#calculate_total_perp_value)[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#nado_protocol.utils.balance.calculate_total_perp_value)**Calculate total unrealized PnL across all perp positions.**Return type:`Decimal`Args:**balances: List of (balance, product) tuples**Returns:**Total unrealized PnL in quote currency (can be positive or negative)**Example:**

`balances = [(btc_perp_balance, btc_perp_product)]
total_pnl = calculate_total_perp_value(balances)
total_pnl
Decimal('10000')  # $10k unrealized profit`

# **See Also[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/margin-manager.html#see-also)**

- [Getting started](https://nadohq.github.io/nado-python-sdk/getting-started.html#getting-started)¬†- SDK basics
- user-guides¬†- Other usage examples
- api-reference¬†- Complete API documentation

# **Order Appendix[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#order-appendix)**

The Order Appendix is a powerful feature in the Nado Protocol that allows you to specify advanced order parameters through a compact bit-packed integer. This appendix encodes various order properties including execution types, isolated positions, TWAP parameters, and trigger types.

# **Overview[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#overview)**

The appendix is a 128-bit integer with the following bit layout (from MSB to LSB):

`| value   | reserved | trigger | reduce only | order type| isolated | version |
| 64 bits | 50 bits  | 2 bits  | 1 bit       | 2 bits    | 1 bit    | 8 bits  |
| 127..64 | 63..14   | 13..12  | 11          | 10..9     | 8        | 7..0    |`

Fields (from LSB to MSB):

- **Version**¬†(bits 0-7): Protocol version for future compatibility (currently version 1)
- **Isolated**¬†(bit 8): Whether the order is for an isolated position
- **Order Type**¬†(bits 9-10): Execution type (DEFAULT, IOC, FOK, POST_ONLY)
- **Reduce Only**¬†(bit 11): Whether the order can only reduce existing positions
- **Trigger Type**¬†(bits 12-13): Type of trigger order (NONE, PRICE, TWAP, TWAP_CUSTOM_AMOUNTS)
- **Reserved**¬†(bits 14-63): Reserved for future use
- **Value**¬†(bits 64-127): Additional data (isolated margin or TWAP parameters)

# **Building an Appendix[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#building-an-appendix)**

Use the¬†**`build_appendix()`**¬†function to create an appendix with the desired parameters:

`from nado_protocol.utils.order import build_appendix
from nado_protocol.utils.expiration import OrderType

# Basic order with IOC execution type
appendix = build_appendix(order_type=OrderType.IOC)

# Reduce-only order
appendix = build_appendix(
    order_type=OrderType.POST_ONLY,
    reduce_only=True
)`

# **Order Execution Types[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#order-execution-types)**

The appendix supports four execution types:

**DEFAULT**Standard limit order behavior**IOC (Immediate or Cancel)**Execute immediately, cancel any unfilled portion**FOK (Fill or Kill)**Execute completely or cancel the entire order**POST_ONLY**Only add liquidity to the order book, never take liquidity

Example:

`from nado_protocol.utils.order import build_appendix
from nado_protocol.utils.expiration import OrderType

# Create different order types
ioc_appendix = build_appendix(order_type=OrderType.IOC)
fok_appendix = build_appendix(order_type=OrderType.FOK)
post_only_appendix = build_appendix(order_type=OrderType.POST_ONLY)`

# **Isolated Positions[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#isolated-positions)**

Isolated positions allow you to allocate specific margin to a trade, limiting your risk:

`from nado_protocol.utils.order import build_appendix
from nado_protocol.utils.expiration import OrderType
from nado_protocol.utils.math import to_x6

# Create isolated position with 1000 USDC margin
# Note: isolated margin uses x6 precision and is limited to 64-bit values
isolated_appendix = build_appendix(
    isolated=True,
    isolated_margin=to_x6(1000),
    order_type=OrderType.POST_ONLY
)`

**Note**

Isolated positions and TWAP orders are mutually exclusive - you cannot have both in the same order.

# **TWAP Orders[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#twap-orders)**

Time-Weighted Average Price (TWAP) orders split large orders into smaller chunks executed over time:

`from nado_protocol.utils.order import build_appendix, OrderAppendixTriggerType

# Create TWAP order with 10 child orders and 0.5% slippage tolerance
twap_appendix = build_appendix(
    trigger_type=OrderAppendixTriggerType.TWAP,
    twap_times=10,
    twap_slippage_frac=0.005
)

# TWAP with custom amounts and reduce-only
twap_custom_appendix = build_appendix(
    trigger_type=OrderAppendixTriggerType.TWAP_CUSTOM_AMOUNTS,
    twap_times=5,
    twap_slippage_frac=0.01,
    reduce_only=True
)`

# **Trigger Orders[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#trigger-orders)**

Trigger orders can be configured with different trigger types:

`from nado_protocol.utils.order import build_appendix, OrderAppendixTriggerType
from nado_protocol.utils.expiration import OrderType

# Price-based trigger order
price_trigger_appendix = build_appendix(
    trigger_type=OrderAppendixTriggerType.PRICE,
    order_type=OrderType.IOC,
    reduce_only=True
)`

# **Extracting Appendix Information[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#extracting-appendix-information)**

You can extract information from an existing appendix:

`from nado_protocol.utils.order import (
    order_version,
    order_execution_type,
    order_reduce_only,
    order_is_isolated,
    order_isolated_margin,
    order_is_trigger_order,
    order_trigger_type,
    order_twap_data
)

from nado_protocol.utils.math import to_x6

appendix = build_appendix(
    isolated=True,
    isolated_margin=to_x6(500),
    order_type=OrderType.IOC,
    reduce_only=True
)

# Extract information
version = order_version(appendix)
execution_type = order_execution_type(appendix)
is_reduce_only = order_reduce_only(appendix)
is_isolated = order_is_isolated(appendix)
margin = order_isolated_margin(appendix)
is_trigger = order_is_trigger_order(appendix)
trigger_type = order_trigger_type(appendix)

print(f"Order Type: {execution_type.name}")
print(f"Reduce Only: {is_reduce_only}")
print(f"Isolated: {is_isolated}")
if margin:
    print(f"Isolated Margin: {margin}")`

# **Using Appendix with Orders[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#using-appendix-with-orders)**

When placing orders, include the appendix in your order parameters:

`from nado_protocol.engine_client.types import OrderParams, PlaceOrderParams
from nado_protocol.utils.order import build_appendix
from nado_protocol.utils.expiration import OrderType
from nado_protocol.utils.subaccount import SubaccountParams
import time

# Create appendix for a reduce-only IOC order
appendix = build_appendix(
    order_type=OrderType.IOC,
    reduce_only=True
)

# Create order with appendix
order = OrderParams(
    sender=SubaccountParams(subaccount_owner="0x...", subaccount_name="default"),
    priceX18=28898000000000000000000,
    amount=-10000000000000000,  # Sell to close position
    expiration=int(time.time()) + 3600,  # 1 hour from now
    appendix=appendix
)

# Place the order
client.market.place_order(PlaceOrderParams(product_id=1, order=order))`

# **Complex Trading Scenarios[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#complex-trading-scenarios)**

Here are examples of complex trading scenarios using appendix:

**Stop Loss Order**

`# Stop loss: reduce-only IOC order that executes immediately when triggered
stop_loss_appendix = build_appendix(
    order_type=OrderType.IOC,
    reduce_only=True,
    trigger_type=OrderAppendixTriggerType.PRICE
)`

**Take Profit Order**

`# Take profit: reduce-only post-only order to avoid paying taker fees
take_profit_appendix = build_appendix(
    order_type=OrderType.POST_ONLY,
    reduce_only=True,
    trigger_type=OrderAppendixTriggerType.PRICE
)`

**Breakout Strategy with Isolated Position**

`from nado_protocol.utils.math import to_x6

# Enter position on breakout with dedicated margin
# Note: isolated margin uses x6 precision and is limited to 64-bit values
breakout_appendix = build_appendix(
    isolated=True,
    isolated_margin=to_x6(5000),  # 5000 USDC dedicated margin
    order_type=OrderType.IOC
)`

**Large Order with TWAP**

`# Split large order into 20 smaller orders with 0.1% slippage tolerance
twap_appendix = build_appendix(
    trigger_type=OrderAppendixTriggerType.TWAP,
    twap_times=20,
    twap_slippage_frac=0.001
)`

# **Validation Rules[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#validation-rules)**

The appendix system enforces several validation rules:

- **Isolated + TWAP Exclusion**: An order cannot be both isolated and a TWAP order
- **TWAP Parameters**: TWAP orders require both¬†twap_times¬†and¬†twap_slippage_frac
- **Isolated Margin**:¬†isolated_margin¬†can only be set when¬†isolated=True
- **Margin Limits**: Isolated margin uses x6 precision and must be between 0 and 2^64 - 1

# **Error Handling[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#error-handling)**

The appendix functions will raise¬†ValueError¬†for invalid configurations:

`from nado_protocol.utils.math import to_x6

# This will raise ValueError: isolated_margin can only be set when isolated=True
try:
    build_appendix(isolated=False, isolated_margin=to_x6(1000))
except ValueError as e:
    print(f"Error: {e}")

# This will raise ValueError: TWAP parameters required
try:
    build_appendix(trigger_type=OrderAppendixTriggerType.TWAP)
except ValueError as e:
    print(f"Error: {e}")

# This will raise ValueError: Isolated and TWAP are mutually exclusive
try:
    build_appendix(
        isolated=True,
        isolated_margin=to_x6(1000),
        trigger_type=OrderAppendixTriggerType.TWAP,
        twap_times=5,
        twap_slippage_frac=0.01
    )
except ValueError as e:
    print(f"Error: {e}")`

# **API Reference[ÔÉÅ](https://nadohq.github.io/nado-python-sdk/order-appendix.html#api-reference)**

For detailed API documentation, see:

- **`nado_protocol.utils.order.build_appendix()`**
- **`nado_protocol.utils.order.order_version()`**
- **`nado_protocol.utils.order.order_execution_type()`**
- **`nado_protocol.utils.order.order_reduce_only()`**
- **`nado_protocol.utils.order.order_is_isolated()`**
- **`nado_protocol.utils.order.order_isolated_margin()`**
- **`nado_protocol.utils.order.order_is_trigger_order()`**
- **`nado_protocol.utils.order.order_trigger_type()`**
- **`nado_protocol.utils.order.order_twap_data()`**
- [**`nado_protocol.utils.order.OrderAppendixTriggerType`**](https://nadohq.github.io/nado-python-sdk/api-reference.html#nado_protocol.utils.OrderAppendixTriggerType)